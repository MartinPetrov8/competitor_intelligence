# CODEBASE PATTERNS & ARCHITECTURE NOTES
# Generated by setup agent for run-832b2370-64ba-43d1-9b29-2c6236abba83
# Date: 2026-02-25

## PROJECT OVERVIEW
- Flask dashboard for competitor intelligence tracking
- SQLite database with v2 schema (one row per competitor per day)
- Python 3.11+ with strict mypy typing
- Pytest for testing (109 passing tests in baseline)

## ROUTING PATTERNS

### Route Definitions
- Routes defined using @app.route() or @app.get() decorators
- Public routes (no auth required) listed in _PUBLIC_ROUTES set: {"/login", "/health"}
- All other routes protected by @app.before_request authentication check
- API routes use /api/ prefix: /api/prices, /api/products, /api/reviews, etc.

### Authentication
- Session-based auth using Flask sessions
- Password checked via secrets.compare_digest() for timing-attack protection
- Default password "changeme" (overridden by DASHBOARD_PASSWORD env var)
- Session key: _AUTH_SESSION_KEY = "authenticated"
- /login route handles both GET (render form) and POST (validate password)
- /logout clears session and redirects to /login

### Response Patterns
- JSON responses use jsonify() from Flask
- Error responses use helper: _json_error(message: str, code: int = 500) -> tuple[Any, int]
- Returns tuple: (jsonify({"error": message}), code)
- Success responses: jsonify(data) for lists/dicts

## DATABASE PATTERNS

### DashboardStore Class
- Constructor: __init__(self, db_path: Path)
- Connection method: _connect() -> sqlite3.Connection (sets row_factory = sqlite3.Row)
- All queries use context manager: with self._connect() as conn:
- Returns list[dict[str, Any]] by converting Row objects: [dict(row) for row in rows]

### Query Patterns
- Filter helper: _build_filters() returns (where_clause: str, params: list[Any])
- JOIN pattern: tables joined to competitors via competitor_id foreign key
- ORDER BY pattern: ORDER BY scrape_date DESC, c.domain ASC
- Column selection alias: c.domain AS competitor (for consistent JSON keys)

### Table Structure
- competitors: (id, domain, base_url, created_at)
- prices_v2: main_price, currency, addons (JSON), UNIQUE(competitor_id, scrape_date)
- products_v2: boolean flags for one_way_offered, round_trip_offered, etc.
- reviews_trustpilot: overall_rating, total_reviews, stars_1-5
- reviews_google: overall_rating, total_reviews
- ab_tests: page_url, tool_name, detected (0/1), evidence
- snapshots: page_type, page_url, html_content, content_hash
- All scraper tables have: competitor_id, scrape_date, scraped_at

## TESTING PATTERNS

### Pytest Fixtures
- Use tmp_path: Path fixture for temporary database
- Fixture pattern:
  ```python
  @pytest.fixture
  def client(tmp_path: Path) -> FlaskClient:
      db_path = tmp_path / "dashboard.db"
      init_database(db_path)
      app = create_app(db_path)
      app.testing = True
      c = app.test_client()
      c.post("/login", data={"password": "changeme"})  # Pre-authenticate
      return c
  ```

### Test Organization
- One test file per module: test_dashboard_server.py, test_pricing_v2.py, etc.
- Test function naming: test_<feature>_<behavior> (e.g., test_api_endpoints_handle_empty_database)
- Helper functions prefixed with underscore: _insert_sample_rows(), _competitor_id()
- Use monkeypatch for environment variables: monkeypatch.setenv("DASHBOARD_PASSWORD", "testpass")

### Database Test Helpers
- _competitor_id(db_path: Path, domain: str) -> int: get competitor ID by domain
- _insert_sample_rows(db_path: Path) -> None: populate test data
- Test data uses realistic domains: "onwardticket.com", "vizafly.com", etc.
- Dates in ISO format: "2026-02-22"

### Assertion Patterns
- assert response.status_code == 200
- assert response.get_json() == expected_data
- assert isinstance(data, list)
- assert len(data) > 0
- assert data[0]["field_name"] == expected_value

## TYPE ANNOTATIONS

### Import Pattern
- from __future__ import annotations (enables forward references)
- Type hints for all functions: def func(arg: str) -> dict[str, Any]:
- Use typing module: from typing import Any, Callable, cast
- Return type for routes: -> Any (Flask allows various response types)

### Common Types
- dict[str, Any] for JSON-like data structures
- list[dict[str, Any]] for API response lists
- str | None for optional strings
- tuple[Any, int] for (response, status_code) pairs

## ERROR HANDLING

### Database Errors
- Wrap queries in try/except sqlite3.Error blocks
- Log exceptions: logging.exception("Failed to load X data")
- Return error response: return _json_error("Failed to load X data")

### HTTP Errors
- Use requests.raise_for_status() to raise on 4xx/5xx
- Catch requests.Timeout separately (configurable timeout)
- Catch requests.RequestException for general HTTP failures
- Log warnings: logging.warning("HTTP error: %s", exc)

## NAMING CONVENTIONS

### Variables
- Snake_case for all variables: competitor_id, scrape_date, source_url
- Underscore prefix for private/helper functions: _connect(), _build_filters()
- Uppercase for constants: DEFAULT_DB_PATH, REQUEST_TIMEOUT_SECONDS
- Double underscore prefix for module-private: __next_data__ (rare)

### Database Columns
- Use snake_case: scraped_at, overall_rating, total_reviews
- Boolean flags: xxx_offered (0/1 INTEGER in SQLite)
- Timestamp columns: created_at, scraped_at (ISO 8601 format)
- Foreign keys: competitor_id (references competitors.id)

### JSON Keys
- Match database column names in API responses (snake_case)
- Use domain name as "competitor" field (from JOIN alias)
- Keep original column names: scrape_date, scraped_at (not camelCase)

## UTILITY FUNCTIONS

### Query Parameter Helper
- _query_param(name: str) -> str | None
- Gets request.args.get(name), strips whitespace, returns None if empty
- Used for filtering: competitor, date, start_date, end_date

### Column Existence Check
- _table_columns(table_name: str) -> set[str]
- Cached in self._columns_cache
- Uses PRAGMA table_info(table_name)
- Returns set of column names

### Metric Expression Builder
- _metric_expr(table, preferred, fallback, alias) -> str
- Returns SQL COALESCE expression if both columns exist
- Handles schema evolution (review_count vs total_reviews)

## CRITICAL PATTERNS TO FOLLOW

1. **Authentication**: Add /health to _PUBLIC_ROUTES set (already exists, keep it there)
2. **Database Methods**: Add new methods to DashboardStore class, not standalone functions
3. **Testing**: Create fixture using tmp_path, init_database(), create_app(), pre-authenticate client
4. **Type Hints**: All new functions must have complete type annotations
5. **Error Handling**: Wrap database queries in try/except sqlite3.Error, return _json_error()
6. **Query Pattern**: Use _connect() context manager, return [dict(row) for row in rows]
7. **Route Decorator**: Use @app.get() for GET-only routes, @app.route() for multi-method
8. **JSON Response**: Always use jsonify(), never return dict directly

## FILES TO MODIFY FOR /health ENHANCEMENT

1. dashboard/server.py:
   - Add get_scraper_count() method to DashboardStore
   - Add get_last_run_timestamp() method to DashboardStore
   - Update health() route handler to call these methods and include in response

2. tests/test_dashboard_server.py:
   - Add test_health_endpoint_with_scraper_data() function
   - Use existing fixture pattern (client fixture with tmp_path)
   - Insert sample data into competitors and scraping tables
   - Assert response contains {"status": "ok", "scrapers": N, "last_run": "timestamp"}

## SCHEMA NOTES FOR /health ENDPOINT

- Scraper count: SELECT COUNT(*) FROM competitors
- Last run timestamp: SELECT MAX(scraped_at) FROM each scraping table (prices_v2, products_v2, reviews_trustpilot, reviews_google, ab_tests, snapshots)
- Use UNION to get max across all tables, then take overall MAX()
- scraped_at columns are ISO 8601 timestamps with UTC
- Return as-is (string), or use datetime.fromisoformat() if needed

## BUILD/TEST COMMANDS

- Build: none (interpreted Python)
- Test: venv/bin/pytest tests/ -x -q
- Lint: venv/bin/mypy . (strict mode, excludes dashboard/ and scrapers/ per mypy.ini)
- Virtual env: venv/ directory (must be created before running tests)

## BASELINE STATUS

- 108 tests passing, 1 test failing in test_dashboard_s11.py::TestProductsApiS11::test_rows_contain_required_fields
- Failure is pre-existing (expects data in database, but test database is empty)
- This is expected for a test that assumes seeded data
- New tests should NOT depend on this failing test
